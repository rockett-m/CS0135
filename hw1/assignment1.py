# -*- coding: utf-8 -*-
"""assignment1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1K35fF2_srmD8EWXUzgic3MnLlFk9B5zE

# Assignment 1
Download auto_mpg.txt and store inside 'tabular' folder created inside of 'data' directory. Add this notebook to your python codebase.

The **purpose** of this assignmnet is to become familiar with core Python (*Part 0*), numpy and Pandas basics (*Part 1*), and handling data (*Part 2*).

NAME
DATE

## Part 0

The goal of Part 0 is to
- Practice problems based on core Python
- Gain better understanding of work-flows controlled by conditional statements

### Resources for python

Here are some of the best resources for Python on the web. 

#### Learning resources

* [Interactive Python](http://interactivepython.org/) An online book that includes embedded live excercises. Fun!
* [Dive Into Python](http://www.diveintopython.net/) An excellent, thorough book.
* [tutorial point](http://www.tutorialspoint.com/python/index.htm) A resource that is useful when you want an explanation of one concept, rather than a whole chapter.


#### Reference resources

Typically, if you have a question about python, you can find an answer by using google. The following sites will usually have the best answer.

* [Official python documentation](https://docs.python.org/3/library/)
* [Quick Reference from Tutorial Point](http://www.tutorialspoint.com/python/python_quick_guide.htm)

**Sample.** Notice the printout below the solution. Notice it is self-documenting, including problem definition and solution (i.e., source code), along with result (i.e., printout).
"""

val = 2
li = [2, 3, 4, 5]
if val in li:
    # print('Found value', val, 'in list')
    print(f'Found value {val} in list')
else:
    print('Value', val, 'not found in list')
if 6 in li:
    print('Found value', 6, 'in list')
else:
    print('Value', 6, 'not found in list')
print('List items:', li)

"""**0.1)** 
Describe the 4 core Python containers (note the keyword core, i.e., not numpy arrays or other container types that are included in Python Packages).  
a) What are characteristics of each?

lists (li=[]), tuples (tu=()), strings (st=""), dictionaries (dic={})-- each are containers with various characteristics.

Lists and tuples can store any type, and can be made up of various different types. Both preserve order (as do strings), with the difference being lists are mutable, while tuples and strings are immutable.

Strings are made up of sequences of characters.

Dictionaries are key-value pairs, where values are accessed via indexing with key. Keys must be unique and are immutable, while values can be of any type and are mutable.

Each container is accessed using square brackets, with indices for tuples, lists, and strings (i.e., ordered) and keys for dictionaries (i.e., unordered).

b) Instantiate each with 0 elements (i.e., empty), and show adding a single element to each.
"""

# instantiate empty containers
my_list = []
my_tuple = ()
my_string = ''
my_dict = {}

# add single elements
elem = 10
my_list.append(elem)
my_tuple = ('value')
my_string = 'value'
my_dict.update({elem : 'value'})

"""c) Provide 1 or more use cases for each.

List: This can be used to store the names of companies in the S&P500.  
Tuple: This can be used to store different types of variables, for example, I am entering a stock order that includes the ticker (string), price (float), size (int), and other information. The tuple can store all these different types in one bundle.  
String: This data struct can store a stock ticker or my name.  
Dictionary: This can be used to have all the names of people in this class (first and last to avoid collisions), paired with their GPA's and or ages.

**0.2)** Write  a program that takes in a positive number (in some variable, say `i`) and computes the sum of all the numbers
between 0 and that number (inclusive). 

a) Do it using a for loop
"""

i = 10

def sum_forloop(n):
    """
    Function that returns the sum of all numbers in range [0, n].
    :param n: upper limit of summation, which is positive integer greater than 0
    :return: Sum from i=0 to i=n.
    """
    if type(n) is not int or n < 0:
        # check input meets conditions
        return None
    sum = 0
    for i in range(n+1):
        sum += i
    return sum

print('Sum using list using for loop', sum_forloop(i))

"""b) Do it in one line using the function `sum` and list comprehension."""

sum([x for x in range(i+1)])

"""**0.3)** Create a lookup table for your class schedule, with the CRN as keys and the name of class as the value. Loop over the dictionary and print out the CRN and course name (single line per class)."""

my_dict = {'CS135': 'Machine Learning', 'EE129': 'Computer Communication Networks'}

for CRN, class_name in my_dict.items():
    print(f'{CRN = }, {class_name = }')

"""**0.4)** Create an empty list. Then, copy the for-loop from previous excercise such that the program prompts you to input the time of the day (as type sting, and using military time would allow for AM and PM to be omitted). These times are to be stored in empty dictionay using the same keys (i.e., CRN->time class starts)"""

import re

my_list = []
new_dict = {}

for CRN, course_name in my_dict.items():
    time_of_day = str(input(f"Enter the time of day in military format for class '{CRN}': "))
    new_dict[CRN] = time_of_day

for CRN, time in new_dict.items():
    if not re.match(r'^([0-9]|[0-1][0-9]|[2][0-3]):([0-5][0-9])(:[0-5][0-9])?$', time):
        print(f'invalid time {time} entered for class {CRN}')

"""**0.5** Write a Python program to convert temperatures to and from Celsius, Fahrenheit.


$$ \frac{c}{5} = \frac{f-32}{9},$$
where $c$ is the temperature in Celsius and $f$ is the temperature in Fahrenheit.

Test code:
60°C is 140 in Fahrenheit
45°F is 7 in Celsius
"""

def fahrenheit2celsius(fahrenheit):
    return (5 * (fahrenheit - 32)) / 9

def celsius2fahrenheit(celsius):
    return ((celsius * 9) / 5) + 32


temp_c = 60
temp_f = 45

temp_c_out = fahrenheit2celsius(temp_f)
temp_f_out = fahrenheit2celsius(temp_c)

print("{} deg. F is {} deg. C".format(temp_f, temp_c_out))
print("{} deg. C is {} deg. F".format(temp_c, temp_f_out))

"""**0.6** Write a Python program to construct the following pattern, using a nested for loop.

O

O X

O X O

O X O X

O X O X O

O X O X

O X O

O X

O
"""

for i in [1,2,3,4,5,4,3,2,1]:
    out = []
    count = i
    for j in range(count):
        if count % 2 == 1:
            out.append('O')
        else:
            out.append('X')
        count -= 1
    if i % 2 == 0:
        out.reverse()
    output = ''.join(out)
    print(output)

"""**0.7** Write a Python program that reads two integers representing a month and day and prints the season for that month and day. Go to the editor
Expected Output:

Input the month (e.g. January, February etc.): july                     
Input the day: 31                                                       
Season is summer  
"""

month = str(input('Please enter the month: ')).strip()
day = int(input('Please enter the day: '))

season_dict = {}
season_dict['winter'] = [['December', 21, 31],  ['January', 31], ['February', 29], ['March', 1, 19]]     # Dec 21 - Mar 19
season_dict['spring'] = [['March', 20, 31],     ['April', 30],   ['May', 31],      ['June', 1, 20]]      # Mar 20 - Jun 20
season_dict['summer'] = [['June', 21, 30],      ['July', 31],    ['August', 31],   ['September', 1, 22]] # Jun 21 - Sep 22
season_dict['autumn'] = [['September', 23, 30], ['October', 31], ['November', 30], ['December', 1, 20]]  # Sep 23 - Dec 20

mths = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December']

def bounds_check():
    error = False

    if day < 1 or day > 31:  # always true
        print(f'Day {day} out of bounds for month {month}'); error = True
    if month not in mths:
        print(f'Month {month} not entered correctly'); error = True

    # need to check days for overlap months
    if not error:
        for season, months in season_dict.items():
            # 4th month in a season doesn't matter here as upper bound is lower
            if month in months[0][0] and day > months[0][2]:
                print(f'Day {day} out of bounds for month {month}'); error = True
            elif (month in months[1][0] and day > months[1][1]) or (month in months[2][0] and day > months[2][1]):
                print(f'Day {day} out of bounds for month {month}'); error = True

    return error

def main(error=False):
    if not error:
        for season, months in season_dict.items():
            # easy middle months cases
            if month in months[1][0] and day <= months[1][1]:
                print(f'Season is {season}')
            elif month in months[2][0] and day <= months[2][1]:
                print(f'Season is {season}')

            # overlap months
            if month in months[0][0] and day >= months[0][1] and day <= months[0][2]:
                print(f'Season is {season}')
            elif month in months[3][0] and day <= months[3][2]:
                print(f'Season is {season}')

error = bounds_check()
main(error)

"""**0.8** Implement repeats(), as specified in doc-string. Then call on variables a and b below. Print True if repeated, else, print False."""

a = [1, 3, 1, 6, 3, 5, 5, 2]
b = [1, 2, 3, 3, 4, 5, 6, 7, 8, 9]

def repeated_val(xs, val=5):
    """Function to search whether 'val' is repeated in sequence.

    :param xs:      List of items to search
    :param val:     Val being searched (default = 5)

    :return:        True if repeated 'val' and neighbors, i.e., [..., 'val', 'val', ...] = True; else, False
    """
    prev = None
    for i in range(len(xs)):
        if i == 0: # first elem
            prev = xs[i]
            continue
        else:
            if (xs[i] == prev) and (xs[i] == val):  # 1) curr equal to prev; 2) curr equal to val
                return True
            prev = xs[i] # set prev to curr before next iteration

    return False

print("list 'a' repeats 5:", repeated_val(a))
print("list 'a' repeats 6:", repeated_val(a, val=6))
print("list 'b' repeats 5:", repeated_val(b))

"""## Part 1

The goal in this part is to
- understand basic functionality of numpy and pandas
- learn how to use numpy and pandas to solve common coding tasks
- understand these packages to process real-world data

Import other libraries, such that numpy library is called by with np and pandas with pd
"""

import os
import numpy as np

"""### a) Numpy Basics
*Make sure to leave random seeds in each cell so that the outputs match the expected answer.

### 1)

Create a 10x10 array with random values and find the minimum and maximum values
"""

np.random.seed(123)
arr = np.random.rand(10, 10)
print(f'{arr = }\n\n{arr.max() = }\n{arr.min() = }')

"""### 2)

Extract the integer part of array Z using 5 different numpy methods
"""

np.random.seed(123)
Z = np.random.uniform(0, 10, 10)

print(f'{Z = }\n')

m1 = np.array(Z, int)
# m2 = [int(x) for x in Z]
m2 = Z-Z%1
m3 = Z.astype(int)
m4 = np.floor(Z)
m5 = np.trunc(Z)

for method in [m1, m2, m3, m4, m5]:
    print(f'{method = }')

"""Create a vector of size 20 with values spanning (0, 1), i.e., 0 and 1 are excluded."""

# np.random.uniform(0, 1, size=20)
# vect = np.linspace(start=0, stop=1, endpoint=False, num=20)

# x0 = np.linspace(start=0, stop=1, num=20, endpoint=True) # has 0 and 1
# x1 = np.linspace(start=0, stop=1, num=20, endpoint=False) # has 0
# x2 = np.linspace(start=0, stop=1, num=20, endpoint=True)[1:-1] # only 18 values
# x3 = np.linspace(start=0, stop=1, num=20, endpoint=False)[1:-1] # only 18 values
x4 = np.linspace(start=0, stop=1, num=22, endpoint=True)[1:-1] # starts with 22 vals, snips off 0,1
x5 = np.linspace(start=0, stop=1, num=21, endpoint=False)[1:] # starts with 21 vals, snips off 0

# print(f'{x0}\n{x1}\n{x2}\n{x3}\n')
print(f'{x4}\n{x5}\n')
# https://www.w3resource.com/python-exercises/numpy/python-numpy-exercise-66.php

"""Create a random vector of size 15 and sort it

"""

np.random.seed(123)
vect = np.random.rand(15)
print(vect)
sorted = np.sort(vect)
print(sorted)

"""Consider two random array A and B, check if they are equal"""

np.random.seed(123)
A = np.random.randint(0, 2, 5)
B = np.random.randint(0, 2, 5)

# np.equal(A, B) # elem by elem
np.array_equal(A, B) # entire array comparison
# np.allclose(A, B) # another option

"""matplotlib is the plotting library which pandas' plotting functionality is built upon, and it is usually aliased to plt.

%matplotlib inline tells the notebook to show plots inline, instead of creating them in a separate window.

plt.style.use('ggplot') is a style theme that most people find agreeable, based upon the styling of R's ggplot package.

See the documentation <https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.plot.html> if you get stuck!

Make an array immutable (read-only)
"""

Z = np.zeros(10)
Z.flags.writeable = False

"""What if we want to plot multiple things? Pandas allows you to pass in a matplotlib Axis object for plots, and plots will also return an Axis object.

Make a bar plot of monthly revenue with a line plot of monthly advertising spending (numbers in millions)


"""

# Commented out IPython magic to ensure Python compatibility.
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
# %matplotlib inline
plt.style.use('ggplot') 

money = {'month' : ['J', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O', 'N', 'D'],
         'revenue' : [4, 6, 7, 11, 9, 13, 17, 24, 25, 28, 31, 36],
         'advertising' : [1, 2, 3, 5, 5, 7, 9, 12, 14, 15, 18, 22]}

df = pd.DataFrame(money); # print(df)
# df.plot(x='revenue', y='advertising', xlabel='revenue (millions)', ylabel='advertising (millions)', color='green', legend=None, title='Advertising Spend vs Monthly Revenue')
# plt.show()

fig, axes = plt.subplots(1, 3, figsize=(30, 8))
df.plot(ax=axes[0], x='month', y='revenue', kind='bar', color='green', xlabel='Month', ylabel='Revenue (millions of USD)', title='Revenue per Month')
df.plot(ax=axes[1], x='month', y='advertising', kind='line', color='green', xlabel='Month', ylabel='Advertising (millions of USD)', title='Advertising Spend per Month')
df.plot(ax=axes[2], x='advertising', y='revenue', kind='hexbin', xlabel='Advertising (millions of USD)', ylabel='Revenue (millions of USD)', title='Advertising Spend vs Monthly Revenue')

"""Create a structured array representing a position (x,y) and a color (r,g,b). Instantiate structured array's values to be all zeros (though same method for other values as well)."""

# arr = [ ( 'position', [('x', float), ('y', float)] ),
#         ( 'color',    [('r', float), ('g', float), ('b', float)] ) ]
# zeroed = np.zeros(10, arr)
# print(zeroed)

arr_np = np.array([((0,0), (0,0,0))],
         dtype = [ ( 'position', [('x', np.float16), ('y', np.float16)] ),
                   ( 'color',    [('r', np.float16), ('g', np.float16), ('b', np.float16)] ) ] )

print(arr_np)

"""Considering a four dimensions array, how to get sum over the last two axis at once? """

np.random.seed(123)
A = np.random.randint(0, 10, (3, 4, 3, 4))
sum = A.sum(axis=(-2,-1))
sum

"""Considering a (w,h,3) image of (dtype=ubyte), compute the number of unique colors

Each color is represented by 3 bits, so the output should be a list of elements, each with 3 bits (all unique permutations of 0s and 1s).

Can you convert colors? How about unique across a different axis?
"""

np.random.seed(123)
w, h = 16, 16
I = np.random.randint(0, 2, (h, w, 3)).astype(np.ubyte)
I.shape

nums_list = []
for matrix in I:
    for bits3 in matrix:
        decimal = bits3[2] * 4 + bits3[1] * 2 + bits3[0]
        nums_list.append(decimal)

print(f'we have {len(list(set(nums_list)))} unique colors in this image\n')

E = len(np.unique(nums_list)) # numpy version
# E

# 3 bits = 8 permutations -> will almost always be 8 but theoretically could be less based on random seed
# 16 rows * 8 perms

"""How to accumulate elements of a vector (X) to an array (F) based on an index list (I)?"""

X = [1, 2, 3, 4, 5, 6]
I = [1, 3, 9, 3, 4, 1]
F = np.bincount(I, X)
F

"""How to read the following file?"""

fpath = os.path.join("data", "tabular", "missing.dat")
with open(fpath, 'r') as fi:
    # fi.readlines()
    for line in fi:
        print(line)

"""
Convert a vector of ints into a matrix binary representation"""

I = np.array([0, 1, 2, 3, 15, 16, 32, 64, 128])
B = ((I.reshape(-1,1) & (2**np.arange(8))) != 0).astype(int)

print(f'{I}\n{B}')

"""Given a two dimensional array, how to extract unique rows?"""

Z = np.random.randint(0, 2, (6, 3))
print(Z)
np.unique(Z, axis=0)

"""## Pandas

Made-up data representing animals and trips to vet
"""

data = {'animal': ['cat', 'cat', 'snake', 'dog', 'dog', 'cat', 'snake', 'cat', 'dog', 'dog'],
        'age': [2.5, 3, 0.5, np.nan, 5, 2, 4.5, np.nan, 7, 3],
        'visits': [1, 3, 2, 3, 2, 3, 1, 1, 2, 1],
        'priority': ['yes', 'yes', 'no', 'yes', 'no', 'no', 'no', 'yes', 'no', 'no']}

labels = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j']

"""Create a DataFrame df from this dictionary data which has the index labels."""

df = pd.DataFrame(data=data, index=labels)
df

"""Display a summary of the basic information about this DataFrame and its data."""

print(f'{df.describe()}\n{df.info()}\n')

"""Return the first 3 rows of the DataFrame df."""

df.head(3)

"""Select just the 'animal' and 'age' columns from the DataFrame df."""

df[['age', 'animal']]

"""Change the age in row 'f' to 1.5."""

df['age']['f'] = 1.5
df

"""
Calculate the mean age for each different animal in df."""

df.groupby('animal')['age'].mean()

""" In the 'animal' column, change the 'snake' entries to 'python'."""

df['animal'] = df['animal'].replace(to_replace='snake', value='python')
df

"""For each animal type and each number of visits, find the mean age. In other words, each row is an animal, each column is a number of visits and the values are the mean ages (hint: use a pivot table)."""

# df.groupby(['animal', 'visits'])['age'].mean()
df.pivot_table(index="animal", columns="visits", aggfunc="mean")["age"]

"""Given a DataFrame, subtract the row mean from each element in the row?"""

# a 5x3 frame of float values
df_floats = pd.DataFrame(np.random.random(size=(5, 3)))
print(df_floats)
# df_floats - df_floats.mean()

df_floats.sub(df_floats.mean(axis=1), axis=0)

"""### Series and Datetimeindex

Create a DatetimeIndex that contains each business day of 2015 and use it to index a Series of random numbers. Let's call this Series s.
"""

index = pd.bdate_range(start='2015-01-01', end='2015-12-31')
# s = pd.DataFrame(np.random.rand(index.shape[0]), index=index)
s = pd.Series(np.random.rand(index.shape[0]), index=index)
s

"""Find the sum of the values in s for every Wednesday."""

# np.sum(s[s.index.dayofweek == 2][0])
s[index.weekday == 2].sum()

"""For each calendar month in s, find the mean of values."""

s.groupby(s.index.month).mean()

"""For each group of four consecutive calendar months in s, find the date on which the highest value occurred."""

s.groupby(pd.Grouper(freq='4M')).idxmax()  # SHOULD NOT BE SPILLING INTO 2016 !!!!!!!!!!!!!!!!!!!!!!!!

# idx = pd.bdate_range(start='2015-01-01', end='2015-09-30')
# t = pd.DataFrame(np.random.rand(idx.shape[0]), index=idx)

# t.groupby(pd.Grouper(freq='4M')).idxmax()

"""### Cleaning Data

The DataFrame to use in the following puzzles:
"""

df = pd.DataFrame({'From_To': ['LoNDon_paris', 'MAdrid_miLAN', 'londON_StockhOlm', 
                               'Budapest_PaRis', 'Brussels_londOn'],
              'FlightNumber': [10045, np.nan, 10065, np.nan, 10085],
              'RecentDelays': [[23, 47], [], [24, 43, 87], [13], [67, 32]],
                   'Airline': ['KLM(!)', '<Air France> (12)', '(British Airways. )', 
                               '12. Air France', '"Swiss Air"']})

df.head()

""" Some values in the the FlightNumber column are missing. These numbers are meant to increase by 10 with each row so 10055 and 10075 need to be put in place. Fill in these missing numbers and make the column an integer column (instead of a float column)."""

prev = ''
arr = []

for entry in df['FlightNumber']:
    value = 0
    if pd.isna(entry):
        value = int(prev + 10)
        arr.append(value)
    else:
        value = int(entry)
        arr.append(value)
    prev = int(value)

df['FlightNumber'] = arr
df

"""The From_To column would be better as two separate columns! Split each string on the underscore delimiter _ to give a new temporary DataFrame with the correct values. Assign the correct column names to this temporary DataFrame."""

from_col = []
to_col = []
for entry in df['From_To']:
    frm, to = entry.split('_')[0], entry.split('_')[1]
    from_col.append(frm); to_col.append(to)

df_temp = pd.DataFrame()
df_temp['From'] = from_col
df_temp['To'] = to_col

df_temp

"""Notice how the capitalisation of the city names is all mixed up in this temporary DataFrame. Standardise the strings so that only the first letter is uppercase (e.g. "londON" should become "London".)"""

df_temp['From'] = df_temp['From'].str.title()
df_temp['To'] = df_temp['To'].str.title()
# df_temp.columns = ['From', 'To']
df_temp

"""Delete the From_To column from df and attach the temporary DataFrame from the previous questions."""

try:
    df = df.drop('From_To', axis=1)
    df = df.join(df_temp)
except:
    pass

df

"""### Plotting
Pandas is integrated with the plotting library matplotlib, and makes plotting DataFrames very user-friendly! Plotting in a notebook environment usually makes use of the following boilerplate:

matplotlib is the plotting library which pandas' plotting functionality is built upon, and it is usually aliased to plt.

%matplotlib inline tells the notebook to show plots inline, instead of creating them in a separate window.

plt.style.use('ggplot') is a style theme that most people find agreeable, based upon the styling of R's ggplot package.

See the documentation <https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.plot.html> if you get stuck!
"""

# Commented out IPython magic to ensure Python compatibility.
import matplotlib.pyplot as plt
import pandas as pd
# %matplotlib inline
plt.style.use('ggplot')

df = pd.DataFrame({"xs":[1,5,2,8,1], "ys":[4,2,1,9,6]})
df

"""### 1.31)
For starters, make a scatter plot of this random data, but use black X's instead of the default markers. Add title "Scatter Plot" to the plot. Use df from previous cell.

*NOTE: Don't forget to add [any] title and axes labels*
"""

df.plot(x='xs', y='ys', kind='scatter', s=100, title='Scatter Plot', color='black', marker='x')
plt.show()

"""Columns in your DataFrame can also be used to modify colors and sizes. Bill has been keeping track of his performance at work over time, as well as how good he was feeling that day, and whether he had a cup of coffee in the morning. Make a plot which incorporates all four features of this DataFrame.

(Hint: If you're having trouble seeing the plot, try multiplying the Series which you choose to represent size by 10 or more)
"""

df2 = pd.DataFrame({"productivity":[5,2,3,1,4,5,6,7,8,3,4,8,9],
                   "hours_in"    :[1,9,6,5,3,9,2,9,1,7,4,2,2],
                   "happiness"   :[2,1,3,2,3,1,2,3,1,2,2,1,3],
                   "caffienated" :[0,0,1,1,0,0,0,0,1,1,0,1,0]})


df2.plot(x='productivity', y='hours_in', s=df2.happiness * 100, c=df2.caffienated, kind='scatter', title="Bill's work performance") # s = size of dots, c = color of dots
plt.show()

"""### 1.33)
What if we want to plot multiple things? Pandas allows you to pass in a matplotlib Axis object for plots, and plots will also return an Axis object.

Make a bar plot of monthly revenue with a line plot of monthly advertising spending (numbers in millions)
- Two plots should be in one figure
- Make sure that the y-axis scales of 2 plots are different
- Be sure to include legend
"""

df_to_plot = pd.DataFrame({"revenue":[57,68,63,71,72,90,80,62,59,51,47,52],
                   "advertising":[2.1,1.9,2.7,3.0,3.6,3.2,2.7,2.4,1.8,1.6,1.3,1.9],
                   "month":range(12)
                  })

fig, axes = plt.subplots(1, 3, figsize=(30, 8))
df_to_plot.plot(ax=axes[0], x='month', y='revenue', kind='bar', color='green', xlabel='Month', ylabel='Revenue (millions of USD)', title='Revenue per Month')
df_to_plot.plot(ax=axes[1], x='month', y='advertising', kind='line', color='green', xlabel='Month', ylabel='Advertising (millions of USD)', title='Advertising Spend per Month')
df_to_plot.plot(ax=axes[2], x='advertising', y='revenue', kind='hexbin', xlabel='Advertising (millions of USD)', ylabel='Revenue (millions of USD)', title='Advertising Spend vs Monthly Revenue')
plt.show()

"""### 1.33)
What if we want to put the x-axis in a different scale? Create two line plots with xs as x-axis and ys as y-axis. First plot uses log scaling on x-axis, and the second plot uses default scaling on x-axis. 
"""

import numpy as np
df3 = pd.DataFrame({"xs":np.logspace(-2, 2, base=10, num=12),
                   "ys":range(12)
                  })

fig, axes = plt.subplots(1, 2, figsize=(30, 8))
df3.plot(ax=axes[0], x='xs', y='ys', xlabel='xs', ylabel='ys', kind='line', color='green', logx=True, title='Logarithmic x-axis: plot of xs vs ys')
df3.plot(ax=axes[1], x='xs', y='ys', xlabel='xs', ylabel='ys', kind='line', color='blue', title='Standard x-axis plot of xs vs ys')
plt.show()

"""##Matrix Manipulations
Lets first create a matrix and perform some manipulations of it.

Using numpy's matrix data structure, define the following matricies:

$$A=\left[ \begin{array}{ccc} 3 & 5 & 9 \\ 3 & 3 & 4 \\ 5 & 9 & 17 \end{array} \right]$$

$$B=\left[ \begin{array}{c} 2 \\ 1 \\ 4 \end{array} \right]$$

After this solve the matrix equation:
$$Ax = B$$
"""

A = np.array([3, 5, 9, 3, 3, 4, 5, 9, 17]).reshape(3,3)
B = np.array([2, 1, 4]).reshape(3,1)
ans = np.linalg.solve(A, B)
print(f'{A}\n{B}\n{ans = }')

"""Now write three functions for matrix multiply $C=AB$ in each of the following styles:

1. By using nested for loops to impliment the naive algorithm ($C_{ij}=\sum_{k=0}^{m-1}A_{ik}B_{kj}$)
2. Using numpy's built in martrix multiplication  

Both methods should have the same answer
"""

temp_arr = []
count = 0; row_sum = 0

for idxi, i in np.ndenumerate(A): # tuple indexing (0,0) ... (2,2)
    count += 1
    for idxj, j in np.ndenumerate(B): # tuple indexing (0,0) ... (2,0)
        if idxi[1] == idxj[0]:
            row_sum += i*j

    if count % len(B) == 0:
        temp_arr.append(row_sum); row_sum = 0

'''
3*2 + 5*1 + 9*4  = 47
3*2 + 3*1 + 4*4  = 25
5*2 + 9*1 + 4*17 = 87
'''
C1 = np.array(temp_arr).reshape(3,1)
# C2 =  np.multiply(A, B)
C2 =  np.dot(A, B)
C3 =  np.matmul(A, B)
C4 = A@B
print(f'{C1 = }\n{C2 = }\n{C3 = }\n{C4 = }\n')

"""## Part 2
Getting used to the data
"""

# Reads text file and uses '|' as separator
auto = pd.read_table('data/tabular/auto_mpg.txt', sep='|')
auto.head()

"""Answer the following questions about the data:

a) What is the shape of the data?
"""

auto.shape

"""b) How many rows and columns are there?"""

print(f'{auto.shape[0]} rows and {auto.shape[1]} columns')

"""c) What variables are available?"""

auto.columns

"""d) What are the ranges for the values in each numeric column?"""

maxes = auto.select_dtypes('number').max()
mins = auto.select_dtypes('number').min()
print(f'mins:\n{mins}\n\nmaxes:\n{maxes}')
# auto.select_dtypes('number').max() - auto.select_dtypes('number').min()

"""e) What is the average value for each column?  Does that differ significantly
  from the median?

In absolute terms, the displacement and weight values differ a decent amount between the average and the median, with horsepower varying as well.
The other categories have very small numerical differences of <= 2 in absolute value.  
If we look at percent change between averages and medians; however, cylinders, displacement, and origin are all significantly different 
at roughly 30% and above.
"""

import warnings # to suppress pesky warnings from interfering from reading the analysis \/ 
warnings.simplefilter(action='ignore', category=FutureWarning)
''' example:
<ipython-input-325-60fbf316ac7b>:1: FutureWarning: Dropping of nuisance columns in DataFrame reductions
 (with 'numeric_only=None') is deprecated; in a future version this will raise TypeError.  
 Select only valid columns before calling the reduction.
'''
averages = auto.mean()
medians = auto.median()
diffs = abs(averages - medians)

pct_change = []
for i, j in zip(averages, medians):
    ans = abs(round( ((j-i)/abs(j) * 100), 2))
    pct_change.append(ans)

temp_df = pd.DataFrame(mins).T # index 0
temp_df.loc[1] = maxes
temp_df.loc[2] = averages
temp_df.loc[3] = medians
temp_df.loc[4] = diffs
temp_df.loc[5] = pct_change

temp_df.index = ['mins', 'maxes', 'averages', 'medians', 'abs difference (avg, med)', 'pct change (avg, med)']
temp_df

"""Answer the following questions about the data:

a) Which 5 cars get the best gas mileage?
"""

auto.sort_values('mpg', ascending=False).head(5)

"""b) Which 5 cars with more than 4 cylinders get the best gas mileage?"""

auto[auto.cylinders > 4].sort_values(by=['mpg'], ascending=False).head(5)

"""c) Which 5 cars get the worst gas mileage?"""

auto.sort_values('mpg', ascending=True).head(5)

"""d) Which 5 cars with 4 or fewer cylinders get the worst gas mileage?"""

auto[auto.cylinders <= 4].sort_values(by=['mpg'], ascending=True).head(5)

"""##Part 3
Use groupby and aggregations to explore the relationships 
between mpg and the other variables.  Which variables seem to have the greatest
effect on mpg?
Some examples of things you might want to look at are:
- What is the mean mpg for cars for each number of cylinders?  
(i.e. 3 cylinders, 4 cylinders, 5 cylinders, etc)?
"""

# mean mpg for each amount of cylinders
dataf = pd.DataFrame(auto.groupby('cylinders')['mpg'].mean())
dataf.reset_index(inplace=True)
dataf.columns = ['cylinders', 'mpg (mean)']
dataf

# Commented out IPython magic to ensure Python compatibility.
import matplotlib.pyplot as plt
import seaborn as sns

# auto.info()
# tell us the number of distinct values and their means per category vs 'mpg'
for count, col in enumerate(auto.columns[1:7]): 
    pass # print(col, count)
    # print(auto.groupby(col)['mpg'].mean())

# ['cylinders', 'displacement', 'horsepower', 'weight', 'acceleration', 'model_year'] # categories we care about vs 'mpg' for graphing

# will want to bin data with many rows ['displacement:81', 'horsepower:93', 'weight:346', 'acceleration:95',  ]
# no need to bin 'cylinders:5' and 'model_year:13' 

# mpg_cyl = pd.DataFrame(data=auto.groupby('cylinders')['mpg'].mean(), columns=['cylinders', 'mpg'])
mpg_cyl = pd.DataFrame(data=auto.groupby('cylinders')['mpg'].mean())
mpg_dpl = pd.DataFrame(data=auto.groupby('displacement')['mpg'].mean())
mpg_hpw = pd.DataFrame(data=auto.groupby('horsepower')['mpg'].mean())
mpg_wgt = pd.DataFrame(data=auto.groupby('weight')['mpg'].mean())
mpg_acc = pd.DataFrame(data=auto.groupby('acceleration')['mpg'].mean())
mpg_myr = pd.DataFrame(data=auto.groupby('model_year')['mpg'].mean())

for datafr in [mpg_cyl, mpg_dpl, mpg_hpw, mpg_wgt, mpg_acc, mpg_myr]:
    datafr.reset_index(inplace=True)

# %matplotlib inline
plt.style.use('ggplot') 

fig, axes = plt.subplots(2, 3, figsize=(30, 12))
mpg_cyl.plot(ax=axes[0, 0], x='cylinders',    y='mpg', kind='bar',  xlabel='cylinders',    ylabel='mpg', title='cylinders vs mpg (avg)',    color='green')
mpg_dpl.plot(ax=axes[0, 1], x='displacement', y='mpg', kind='line', xlabel='displacement', ylabel='mpg', title='displacement vs mpg', color='blue')
mpg_hpw.plot(ax=axes[0, 2], x='horsepower',   y='mpg', kind='line', xlabel='horsepower',   ylabel='mpg', title='horsepower vs mpg',   color='purple')
mpg_wgt.plot(ax=axes[1, 0], x='weight',       y='mpg', kind='line', xlabel='weight',       ylabel='mpg', title='weight vs mpg',       color='orange')
mpg_acc.plot(ax=axes[1, 1], x='acceleration', y='mpg', kind='line', xlabel='acceleration', ylabel='mpg', title='acceleration vs mpg', color='red')
mpg_myr.plot(ax=axes[1, 2], x='model_year',   y='mpg', kind='bar',  xlabel='model_year',   ylabel='mpg', title='model_year vs mpg (avg)',   color='teal')

plt.show()

"""
How has mpg trended over the years?  
Over the years, average mpg has trended upwarded (increased). See plot 6 of 6. """

auto.sort_values('model_year', inplace=True)
auto # https://datatofish.com/sort-pandas-dataframe/

"""What is the mpg for the group of lighter cars vs the group of heavier cars?  
Note: Be creative in the ways in which you divide up the data.  You are trying
to create segments of the data using logical filters and comparing the mpg
for each segment of the data.

The mpg for the lighter cars is typically much higher than for heavier cars, as we would expect.
"""

# From chart above:
# Car weight range: (1613 - 5140 pounds)
# Car weight average (2977.58 pounds)
# Car weight median: (2803.5 pounds)

# https://stackoverflow.com/questions/17411940/matplotlib-scatter-plot-legend

light = pd.DataFrame(auto[auto.weight <= auto['weight'].mean()].sort_values(by=['model_year'], ascending=True), columns=['model_year', 'weight', 'mpg'])
heavy = pd.DataFrame(auto[auto.weight > auto['weight'].mean()].sort_values(by=['model_year'], ascending=True), columns=['model_year', 'weight', 'mpg'])
# print(f'{light}\n{heavy}\n')

g0 = plt.scatter(x=light['mpg'], y=light['weight'])
g1 = plt.scatter(x=heavy['mpg'], y=heavy['weight'])
plt.legend((g0, g1), ('light weight cars', 'heavy weight cars'),
            scatterpoints=1, loc='upper right', ncol=3, fontsize=10)
plt.gca().update(dict(xlabel='efficiency (mpg)', ylabel='weight (lbs)', title='heavy and light cars with their mpg'))
plt.show()

"""Let's now look how MPG has changed over time, while also considering
how specific groups have changed-- look at low, mid, and high power
cars based upon their horsepower and see how these groups have changed over time.

Defines low power as below 100 horsepower  
Defines mid power as between 100 and 150 (inclusive) horsepower  
Defines high power as above 150 horsepower

In his data, he called the original dataset 'auto'.

**Now to look at how efficency has changed over time based on power and weight classes, two things that we know play a large role in gas mileage.  First, we create a table of efficiency by power class and year.**
"""

# MY, HP, MPG in that priority (low to high) sort...power levels defined above
low_power = auto[auto["horsepower"] < 100].sort_values(by=['model_year', 'horsepower', 'mpg'], axis=0, ascending=[True, True, True])
med_power = auto[(auto["horsepower"] >= 100) & (auto["horsepower"] < 150)].sort_values(by=['model_year', 'horsepower', 'mpg'], axis=0, ascending=[True, True, True])
high_power = auto[auto["horsepower"] > 150].sort_values(by=['model_year', 'horsepower', 'mpg'], axis=0, ascending=[True, True, True])

# high_power

p1 = plt.scatter(x=low_power['model_year'], y=low_power['mpg'], color='green')
p2 = plt.scatter(x=med_power['model_year'], y=med_power['mpg'], color='blue')
p3 = plt.scatter(x=high_power['model_year'], y=high_power['mpg'], color='red')

plt.legend((p1, p2, p3), ('low_power', 'med_power', 'high_power'), 
           scatterpoints=1, loc='upper left', ncol=3, fontsize=10)
plt.gca().update(dict(xlabel='model year', ylabel='efficiency (mpg)', title='Car power levels and efficiency (mpg) from model years 1970-1982'))
plt.rcParams["figure.figsize"] = (10, 10)
plt.show()

"""We see here that efficiency trends upwards based on model year in the low horsepower category.  
There are no cars at the most recent years (1980-1982) so it is harder to draw a conclusion of mpg trends. It appears as if the worst mpg cars for the high HP category only existing from 1970-1973 with overall mpg averages improving in the 1970s for the cars in the dataset.  
The medium HP cars improved in the 1980s, but there are less of them in that time period than the 1970s for each year. The peaks of mpg's absolutely improved for medium HP cars from 1979-1983.
"""

light_weight = auto[auto.weight <= auto['weight'].mean()].sort_values(by=['model_year', 'weight'], ascending=[True, True])
heavy_weight = auto[auto.weight > auto['weight'].mean()].sort_values(by=['model_year', 'weight'], ascending=[True, True])

# heavy_weight

k0 = plt.scatter(x=light['model_year'], y=light['weight'])
k1 = plt.scatter(x=heavy['model_year'], y=heavy['weight'])
plt.legend((k0, k1), ('light weight cars', 'heavy weight cars'),
            scatterpoints=1, loc='upper right', ncol=3, fontsize=10)
plt.gca().update(dict(xlabel='model year', ylabel='weight (lbs)', title='heavy and light from model years 1970-1982'))
plt.show()

"""As the years progress from 1970 to 1982, the amount of light cars (below the mean of ~2977.58 pounds) is very consistent; however, the amount of heavy cars drops significantly.  
The peak weight per model year shows a consistent downtrend as well.
"""